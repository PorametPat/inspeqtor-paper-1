from .data import ExpectationValue

import torch
import torch.nn as nn
import torch.nn.functional as F
import numpy as np


def calculate_exp(
    unitary: torch.Tensor, operator: torch.Tensor, density_matrix: torch.Tensor
) -> torch.Tensor:
    # density_matrix = torch.outer(initial_state, initial_state.T.conj())
    rho = torch.matmul(unitary, torch.matmul(density_matrix, unitary.T.conj()))
    temp = torch.matmul(rho, operator)
    return torch.real(torch.trace(temp))


def Wo_2_level(
    U: torch.Tensor,
    D: torch.Tensor,
) -> torch.Tensor:

    alpha = U[0]
    theta = U[1]
    beta = U[2]

    lambda_1 = D[0]
    lambda_2 = D[1]

    q_00 = torch.exp(1j * alpha) * torch.cos(theta)
    q_01 = torch.exp(1j * beta) * torch.sin(theta)
    q_10 = torch.exp(-1j * beta) * torch.sin(theta)
    q_11 = -torch.exp(-1j * alpha) * torch.cos(theta)

    # Q = torch.tensor([[q_00, q_01], [q_10, q_11]])
    Q = torch.cat(
        [torch.stack([q_00, q_10], dim=0), torch.stack([q_01, q_11], dim=0)], dim=1
    ).type(torch.cfloat)

    # _D = torch.tensor([[lambda_1, 0], [0, lambda_2]])
    _D = torch.diag_embed(torch.cat([lambda_1, lambda_2], dim=0)).type(torch.cfloat)

    return Q @ _D @ Q.T.conj()

def Wo_2_level_v2(U: torch.Tensor, D: torch.Tensor) -> torch.Tensor:
    """
    Constructs a Hermitian traceless operator from the given parameters.

    Args:
        params (tuple[torch.Tensor, torch.Tensor]): A tuple containing two tensors representing the parameters.
            - The first tensor (params_U) contains the parameters for the eigenvector matrix. It has shape (batch_size, 3),
            where each row represents a set of parameters for a single operator.
            The columns of params_U represent the following parameters:
                - Column 0: theta - the angle parameter
                - Column 1: alpha - the alpha parameter
                - Column 2: beta - the beta parameter
            - The second tensor (params_D) contains the parameters for the eigenvalue matrix. It has shape (batch_size, 2),
            where each row represents a set of parameters for a single operator.
            The columns of params_D represent the following parameters:
                - Column 0: lambda_1 - the first eigenvalue parameter
                - Column 1: lambda_2 - the second eigenvalue parameter

    Returns:
        torch.Tensor: The constructed Hermitian traceless operator. It has shape (batch_size, 2, 2), where each 2x2 matrix
        represents the operator for a single set of parameters.

    Note:
        The constructed operator is obtained by parametrizing the eigenvector matrix as described in
        https://en.wikipedia.org/wiki/Unitary_matrix. The eigenvalue matrix is constructed to be traceless.
        This docstring was generated by Codium (I added this line manually)

    """
    # parametrize eigenvector matrix being unitary as in https://en.wikipedia.org/wiki/Unitary_matrix

    params_U = U
    theta = params_U[:, 0:1]
    alpha = params_U[:, 1:2]
    beta = params_U[:, 2:3]

    params_D = D
    lambda_1 = params_D[:, 0:1]
    lambda_2 = params_D[:, 1:2]
    # global_phase = torch.exp(1j * U[:, 3:4] / 2)

    q_00 = torch.exp(1j * alpha) * torch.cos(theta)
    q_01 = torch.exp(1j * beta) * torch.sin(theta)
    q_10 = -torch.exp(-1j * beta) * torch.sin(theta)
    q_11 = torch.exp(-1j * alpha) * torch.cos(theta)

    Q = torch.cat(
        [torch.stack([q_00, q_10], dim=1), torch.stack([q_01, q_11], dim=1)], dim=2
    )

    Q = Q.type(torch.cfloat)

    # construct eigenvalue matrix such that it is traceless
    D = torch.diag_embed(torch.cat([lambda_1, lambda_2], dim=1)).type(torch.cfloat)

    # construct the Hermitian tracelesss operator from its eigendecompostion
    Wo = torch.bmm(torch.bmm(Q, D), Q.mH)

    return Wo

def get_predict_expectation_value(
    Wos_params: dict[str, dict[str, torch.Tensor]],
    unitaries: torch.Tensor,
    evaluate_expectation_values: list[ExpectationValue],
) -> torch.Tensor:

    # predict_expectation_values = []
    predict_expectation_values = torch.zeros([len(evaluate_expectation_values), unitaries.shape[0]])

    # Calculate expectation values for all cases
    for idx, exp_case in enumerate(evaluate_expectation_values):
        # Wo = torch.vmap(Wo_2_level, in_dims=(0, 0))(
        #     Wos_params[exp_case.observable]["U"], Wos_params[exp_case.observable]["D"]
        # )
        Wo = Wo_2_level_v2(
            Wos_params[exp_case.observable]["U"], Wos_params[exp_case.observable]["D"]
        )
        # Calculate expectation value for each pauli operator
        batch_expectaion_values = torch.vmap(calculate_exp, in_dims=(0, 0, None))(
            unitaries,
            Wo,
            torch.tensor(np.array(exp_case.initial_density_matrix)).type(torch.cfloat),
        )

        # predict_expectation_values.append(batch_expectaion_values)
        predict_expectation_values[idx] = batch_expectaion_values

    return predict_expectation_values


def variance_of_observable(expval: torch.tensor, shots: int = 1):
    return (1 - expval**2) / shots
